/*
 * Library 	: SCCodeGeneration 
 *		Code generation from UML StateCharts with semantic variation points 
 *		and different implantation choice
 *
 * File 	: $RCSfile: Main.mtl,v $
 * Purpose 	: Define the front class of the whole transformation
 *
 * Authors	: Franck Chauvel
 * Created	: 10/05/2004
 * Version	: $Revision: 1.1 $
 * 
 * $Log: not supported by cvs2svn $
 *
 */
 

library Main;



model UML				:	RepositoryModel; 	// The UML model	
model semanticModel 	:	RepositoryModel; 	// The Semantic model
model uml				:	UML_Utils;			// The UML Helpers library


main(){
	mdrdriver       : 	MDRDriver::MDRModelManager;
	transfo			:	MainClass;
	
	
	// we initialize the MDR driver			
	mdrdriver := new MDRDriver::MDRModelManager();
	mdrdriver.init();
		 
	// intanciate the UML model, save result in another file
	UML := mdrdriver.getModelFromXMI (
		'./Metamodels/UML_metamodel.xml', 			// Meta model File Name
		'UML',										// name of the root package in the Uml1.4 metamodel
		'CD_Player_updated',					 	// name of the new model in the repository
		'./Models/CD_Player.xml',
		'./Models/CD_Player_updated.xml'
	);		
	
	
	// intanciate the Semantic model, save result in another file
	semanticModel := mdrdriver.getModelFromXMI (
		'./Metamodels/MM_semantic_MOF.xml', 		// Meta model File Name
		'MM_semantic',								// name of the root package in the Uml1.4 metamodel
		'Gibolin',								 	// [Powered by E. Drézen]
		'./Models/Model_semantic.xml',
		'./Models/Model_semantic_updated.xml'
	);		
	
	
	// We Initialise UML_Utils functions library
	uml := new UML_Utils();
	uml.init(UML);

	
	// Create a new Object an run the transformation
	transfo := new MainClass();
	transfo.run();
	
}



class MainClass
{

	theSemantic		:	SCSView::StatechartsSemantic;
	
	init()
	{
		adapterFactory 	: 	SCSAdapter::AdapterFactory;
		theFactory		:	SCSView::ViewFactory;
	
	
		// Get the MTL view of the Semantic Model
		adapterFactory := new SCSAdapter::AdapterFactory();
		theFactory := adapterFactory;
		theFactory.init(semanticModel);
		theSemantic := theFactory.getViewOfSemantic();
	}
	

	run()
	{
		builder			:	SCCodeGeneration::CodeGenerationBuilder;	
		codeGen			: 	SCCodeGeneration::CodeGeneration;
			
		'Starting the Transformation ...'.toOut();
		foreach ( aClass : UML::Core::Class) where ( uml.hasOneBehavior(aClass) ) {
			'-> Processing the Class : '.concat(aClass.name.oclAsType(!Standard::String!)).toOut();
			builder := new SCCodeGeneration::CodeGenerationBuilder();
			builder.initLib(UML);
			builder.init(
				uml.getFirstElement(uml.getAllBehaviorsOfElement(aClass)).oclAsType(!UML::State_Machine::StateMachine!),
				theSemantic
			);
			
			builder.visitStateMachine();
			codeGen := builder.getResult();
			codeGen.setTargetClass(aClass);
			
			// Start the CodeGeneration
			codeGen.run();
			
		}
		
	}

}