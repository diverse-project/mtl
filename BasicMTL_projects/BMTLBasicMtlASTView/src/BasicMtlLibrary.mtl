// $Id: BasicMtlLibrary.mtl,v 1.4 2003-12-08 11:23:29 jpthibau Exp $
// part of the BasicMtlASTView Library ( view on ASTJava )
/* version written for basicmtl.g,v 1.2
 *	(cf /udd/triskell/cvsroot/dev/MT/BasicMtlAntlr/ANTLRParser/basicmtl.g,v 1.2)
 */
 
 library BasicMtlASTView;
 
 class BasicMtlLibrary extends Library {
 
	parameters : Standard::Set;
	
	appendParameters ( aModel : ModelRef) : Standard::Void
	{	if isNull(parameters)
			{ JavaCode [BMTL_parameters=new BMTLSet()]; }
		parameters := parameters.including(aModel).oclAsType(!Standard::Set!);
	}

	toASTJava() : ASTJava::Object
	{
	qnames,theParameters,classes,operations,properties : Standard::Iterator;
	aNamePart : Standard::String;
	aParameter : ModelRef;
	aClass : UserClass;
	anOperation : Operation;
	aProperty : Property;
	JavaCode [org.irisa.triskell.MT.BasicMTL.BasicMTLAST.Java.BasicMtlLibrary theBasicMtlLibrary=new org.irisa.triskell.MT.BasicMTL.BasicMTLAST.Java.BasicMtlLibrary(this.get_BMTL_name().getTheString())];
	if isNull(self.oclAsType(!Library!).QualifiedName).[not]() {
	qnames := self.oclAsType(!Library!).QualifiedName.getNewIterator();
	qnames.start();
	while qnames.isOn() {
		aNamePart := qnames.item().oclAsType(!Standard::String!);
		JavaCode [theBasicMtlLibrary.appendQualifiedName(BMTL_aNamePart.getTheString())];
		qnames.next();
	}
	}
	if isNull(parameters).[not]() {
	theParameters := parameters.getNewIterator();
	theParameters.start();
	while theParameters.isOn() {
		aParameter := theParameters.item().oclAsType(!ModelRef!);
		JavaCode [theBasicMtlLibrary.appendParameters((org.irisa.triskell.MT.BasicMTL.BasicMTLAST.Java.ModelRef)BMTL_aParameter.BMTL_toASTJava())];
		theParameters.next();
	}
	}
	if isNull(self.oclAsType(!Library!).definedOperations).[not]() {
	operations := self.oclAsType(!Library!).definedOperations.getNewIterator();
	operations.start();
	while operations.isOn() {
		anOperation := operations.item().oclAsType(!Operation!);
		JavaCode [theBasicMtlLibrary.appendDefinedOperations((org.irisa.triskell.MT.BasicMTL.BasicMTLAST.Java.Operation)BMTL_anOperation.BMTL_toASTJava())];
		operations.next();
	}
	}
	if isNull(self.oclAsType(!Library!).definedClasses).[not]() {
	classes := self.oclAsType(!Library!).definedClasses.getNewIterator();
	classes.start();
	while classes.isOn() {
		aClass := classes.item().oclAsType(!UserClass!);
		JavaCode [theBasicMtlLibrary.appendDefinedClasses((org.irisa.triskell.MT.BasicMTL.BasicMTLAST.Java.UserClass)BMTL_aClass.BMTL_toASTJava())];
		classes.next();
	}
	}
	properties := self.oclAsType(!ASTNode!).decoration.getNewIterator();
	properties.start();
	while properties.isOn() {
		aProperty := properties.item().oclAsType(!Property!);
		JavaCode [theBasicMtlLibrary.appendDecoration((org.irisa.triskell.MT.visitors.Java.AnalysingVisitor.Property)BMTL_aProperty.BMTL_toASTJava())];
		properties.next();
	}
	JavaCode [return theBasicMtlLibrary];
	}

	addClass(className : Standard::OrderedSet) : Standard::Void
	{
	theInheritance : Standard::Set;
	anInheritedParent : Standard::OrderedSet;
	theCreatedClass : UserClass;
	theLibName,theName : Standard::String;
	names  : Standard::Iterator;
	names := className.getNewIterator();
	names.start();
	theLibName := names.item().oclAsType(!Standard::String!); 
	names.next(); //skip the library name
	theName := names.item().oclAsType(!Standard::String!);
	names.next(); 
	theCreatedClass := new UserClass();
	theCreatedClass.name := theName;
	theInheritance := new Standard::Set();
	anInheritedParent := new Standard::OrderedSet();
	anInheritedParent := anInheritedParent.append(theLibName);
	anInheritedParent := anInheritedParent.append(theName);
	theInheritance := theInheritance.including(anInheritedParent);
	//keep all local inheritances in the copy of the class
	while names.isOn() {
		anInheritedParent := new Standard::OrderedSet();
		anInheritedParent := anInheritedParent.append(names.item().oclAsType(!Standard::String!));
		theInheritance := theInheritance.including(anInheritedParent);
		names.next();
	}
	theCreatedClass.oclAsType(!ASTNode!).createNewInheritanceProperty('Inheritance',theInheritance,'InheritanceTag');
	theCreatedClass.oclAsType(!ASTNode!).createNewStringProperty('LineNumber','-100000','StringTag'); //we should have a LineNumber for ASTJava 2 code generation : -100 000 may mean generated by inheritance transformation
	self.oclAsType(!Library!).appendDefinedClasses(theCreatedClass);
	}

	isRefined(className : Standard::OrderedSet;refinedClasses : Standard::Set) : Standard::Boolean
	{
	theLibName,theClassName : Standard::String;
	refinedNames,names  : Standard::Iterator;
	aRefinedName : Standard::OrderedSet;
	names := className.getNewIterator();
	names.start();
	theLibName := names.item().oclAsType(!Standard::String!); 
	names.next();
	theClassName := names.item().oclAsType(!Standard::String!);
	refinedNames := refinedClasses.getNewIterator();
	refinedNames.start();
	while refinedNames.isOn() {
		aRefinedName := refinedNames.item().oclAsType(!Standard::OrderedSet!);
		names := aRefinedName.getNewIterator();
		names.start();
		if theLibName.[=](names.item().oclAsType(!Standard::String!))
		{	names.next();
			if theClassName.[=](names.item().oclAsType(!Standard::String!))
			{	return true; }
		}
		refinedNames.next();
		}
	 return false;
	}
	
	addLibraries(inheritance : Standard::Set; refinedClasses : Standard::Set) : Standard::Void
	{
	librariesNames,classes : Standard::Iterator;
	aLibName,aClassName : Standard::OrderedSet;
	inheritedClasses : Standard::Set;
	librariesNames := inheritance.getNewIterator();
	librariesNames.start();
	while librariesNames.isOn() {
		aLibName := librariesNames.item().oclAsType(!Standard::OrderedSet!);
		inheritedClasses := self.allKnownClasses(aLibName);
		classes := inheritedClasses.getNewIterator();
		classes.start();
		while classes.isOn() {
			aClassName := classes.item().oclAsType(!Standard::OrderedSet!);
			if isRefined(aClassName,refinedClasses).[not]()
				{	addClass(aClassName); }
			classes.next();
		}
		librariesNames.next();
	}
	}
	
	findRefinedClasses() : Standard::Set
	{
	properties,userClasses : Standard::Iterator;
	theSet : Standard::Set;
	aClass : UserClass;
	aProperty : Property;
	theSet:=new Standard::Set();
	userClasses := self.oclAsType(!Library!).definedClasses.getNewIterator();
	userClasses.start();
	while userClasses.isOn() {
		aClass := userClasses.item().oclAsType(!UserClass!);
		properties := aClass.oclAsType(!ASTNode!).decoration.getNewIterator();
		properties.start();
		while properties.isOn() {
			aProperty := properties.item().oclAsType(!Property!);
			if aProperty.name.[=]('Refinement')
			{
			theSet := theSet.union(aProperty.oclAsType(!InheritanceProperty!).value);
			}
			properties.next();
		}
		userClasses.next();
	}
	return theSet;
	}
	
	transformInheritedLibrary() : Standard::Void
	{
	refinedClasses : Standard::Set;
	properties: Standard::Iterator;
	aProperty : Property;
	refinedClasses := null;
	properties := self.oclAsType(!BasicMtlASTView!).oclAsType(!ASTNode!).decoration.getNewIterator();
	properties.start();
	while properties.isOn() {
		aProperty := properties.item().oclAsType(!Property!);
		if aProperty.name.[=]('Inheritance')
		{
		//find the declared refined classes of thislib, if not already done
		if isNull(refinedClasses)
		   {	refinedClasses := findRefinedClasses(); }	
		addLibraries(aProperty.oclAsType(!InheritanceProperty!).value,refinedClasses);
		}
		properties.next();
	}
	}

 }