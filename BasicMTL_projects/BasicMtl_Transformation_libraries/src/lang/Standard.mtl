// -----------------------------------------------------------------------------
// $Id: Standard.mtl,v 1.3 2003-07-30 13:31:13 dvojtise Exp $
// concrete syntax : to be discussed as it is not the currently implemented one
//		- how to indicate the map to the concrete native java methods and classes
//  	- how to represent the class void [] or ""
//		- infix and prefix
// 		- function return value position  ie.  : or before the function name
//		- standart comments :  "à la" javadoc ?
//		- pre, post usage, probably in a later version of the compiler as it needs more than just concrete syntax
// 		- parametrized class syntax : not supported in initial version of the language. 
//			currently use OclAny + casting to achieve this
/* version written for BasicMtl 1.1 ???
 *	(cf /udd/triskell/cvsroot/dev/MT/BasicMtlAntlr/ANTLRParser/basicmtl.g,v 1.1)
 */
// defines the Primitive types
// this is a Native BasicMTL library, this means that it is implemented in the target language

// Initially, this library is not intended to be fully generated, it is here only for documentation of 
// the available primitives types and their operations. 
// However, later, It will be used as a native library

// the infix notation indicates that the programmer can use either
// a + b 
// or 
// a.+(b)
// notations
// the prefix : - a      or a.-()   notations

/* @TODO : see how this definitions can map to Frederic's commands and invoke mecanism in the native language (ie. Java)
// @TODO : add infix and prefix to the syntax (for operator redefinition
// @TODO : correct the file 
// @TODO : add informations indicating "not implemented yet" where necessary + mapping to a special function that will throw an exception for that.
// @TODO : discuss the use of directories and libraries for naming and grouping the classes, how shold they be differents ? in which case using this grouping or the other ?
//		ex, separating primitives types from collections, ..
//		can we separate the classes in differents files but keeping le library consistence ?
// @TODO : add OclMessage, OclModelElement, OclType and OclState ?
// @TODO : rename void to OclVoid ? or propose both for BMTL and Ocl compliance ?
// @TODO : verify the use of the T type in ocl, for collections this is a parametrized class but for OclAny ?
// @TODO : allow to separate all theses classes in separate files for easier editing and versionning. (not separate libraries)
// @TODO : Add a mecanism that will put a version identifier in the libraries
// @TODO : correct OclAny, (use of OclType ?, use of a template ?)
*/
// -----------------------------------------------------------------------------

/**
  * Defines the standart primitives types on which the compiler relies.
  * It defines also the operations availables.
  * It is based on the OCL 2.0 definition as expressed in omg document ad/2003-09-03 (OCL 2.0 REVISED SUBMISSION VERSION 1.6, JANUARY 6, 2003 6-6)
  */
Library Standard
tag mangle = Java TagString [org.irisa.triskell.MT.DataTypes.Java.defaultImpl] 
tag DoNotGenerate = TagBoolean [true]


// *************
// * OCL types *
// *************
class OclAny {
	/** equal
	  * Note : equality may be discussed it may express the need of a identity, value equality, deep value equality, ?
	  * True if self is the same object as object2. Infix operator.
	  * post: result = (self = object2)
	  */
	infix "=" (value : OclAny) : boolean {		
	}
	
	/** Not equal
	  * True if self is a different object from object2. Infix operator.
	  * post: result = not (self = object2)
	  */
	infix "<>" (value : OclAny) : boolean {
	}

	/* oclIsNew() : Boolean
	{
		// Can only be used in a postcondition. Evaluates to true if the self is created during performing the operation.
		// I.e. it didn’t exist at precondition time.
		// post: self@pre.oclIsUndefined()
	}*/
	
	oclIsUndefined() : Boolean
	{
		// Evaluates to true if the self is equal to OclUndefined.
		// post: result = self.isTypeOf( OclVoid )
	}
	
	oclAsType(typename : OclType) : T
	{
		// Evaluates to self, where self is of the type identified by typename. Typename may be in the format
		// Package::subPackage::classifier.
		// post: (result = self) and result.oclIsTypeOf( typeName )
	}
	
	oclIsTypeOf(typename : String) : Boolean
	{
		// Evaluates to true if the self is of the type identified by typename. Typename may be in the format
		// Package::subPackage::classifier.
		// post: -- TBD
	}
	oclIsTypeOf(typename : OclType) : Boolean
	{
		// Evaluates to true if the self is of the type identified by typename. Typename may be in the format
		// Package::subPackage::classifier.
		// post: -- TBD
	}
	
	oclIsKindOf(typename : OclType) : Boolean
	{
		// Evaluates to true if the self conforms to the type identified by typename. Typename may be in the format
		// Package::subPackage::classifier.
		// post: -- TBD
	}
	oclIsKindOf(typename : String) : Boolean
	{
		// Evaluates to true if the self conforms to the type identified by typename. Typename may be in the format
		// Package::subPackage::classifier.
		// post: -- TBD
	}
	
	/* oclIsInState(statename : OclState) : Boolean
	{
		// Evaluates to true if the self is in the state indentified by statename. Statename may be in the format
		// Class::State::subState.
		// post: -- TBD
	}*/
	
	/* the allInstances is a static method implemented on every library
	allInstances() : Set( )
	{
		// Returns all instances of self. Type T is equal to self. May only be used for classifiers that have a finite
		// number of instances. This is the case for, for instance, user defined classes because instances need to be
		// created explicitly. This is not the case for, for instance, the standard String, Integer, and Real types.
		// pre: self.isKindOf( Classifier ) -- self must be a Classifier
		// 		and -- TBD -- self must have a finite number of instances
		// -- it depends on the UML 2.0 metamodel how this can be
		// -- expressed
		// post: -- TBD
	}
	*/
	
}


class OclType extends OclAny
{
	newInstance() : OclAny
	{
	}
	
	allInstances() : Set
	{
	}
	getQualifiedName() : Sequence
	{
	}
}

class ModelElement extends OclAny
{	

	/*
	associate(role1 : String, type1 : String, role2 : String, associatedME : OclAny, type2 : String) : Void
	{
		// Does the reifycation between this element with associatedME getting informations from rolename and type name
		// this.role2 = associatedME
		// associatedME.role1 = this
	}
	dissociate(role1 : String, type1 : String, role2 : String, dissociatedME : OclAny, type2 : String) : Void
	{
		// Does the reifycation between this element with associatedME getting informations from rolename and type name
		// this.role2 = associatedME
		// associatedME.role1 = this
	}	
	*/
	
	delete()
	{
	}
	getuid() : String
	{
	}
}




// *******************
// * Primitive types *
// *******************
class boolean extends OclAny
{
	boolean prefix "not"(value:boolean){}
	boolean infix "and"(value:boolean){}
	boolean infix "or"(value:boolean){}
	boolean infix "xor"(value:boolean){}
	boolean infix "implies"(value:boolean){}
}

class [void] extends OclAny
tagDomain mangle tag Java TagString VoidValueImpl
endTag
{}

/**
  * Note that integer is a subclass of real, so for each parameter of type Real, you can use an integer as the actual
parameter.
  */
class real extends OclAny{

	/**
  	  * The value of the addition of self and r.
  	  */
	infix "+" (r : real) : real 
	{}

	/**
	  * The value of the subtraction of r from self.
	  */
	infix "-" (r : real) : real 
	{}

	/**
	  * The value of the multiplication of self and r.
	infix "*" (r : real) : real 
	java [ this * r]
	{}

	/**
	  * The negative value of self.
	  */
	prefix "-" : real 	
	{}
	
	/**
	  * The value of self divided by r.
	  */
	infix "/" (r : real) : real
	{}

	/**
	  * The absolute value of self.
	  * post: if self < 0 then result = - self else result = self endif
	  */
	abs() : real
	{}

	/**
	  * The largest integer which is less than or equal to self.
	  * post: (result <= self) and (result + 1 > self)
	  */	  
	floor() : integer
	{}
	
	/**
	  * The integer which is closest to self. When there are two such integers, the largest one.
	  * post: ((self - result).abs() < 0.5) or ((self - result).abs() = 0.5 and (result > self))
	  */
	round() : integer
	{}

	/**
	  * The maximum of self and r.
	  * post: if self >= r then result = self else result = r endif
	  */
	max(r : Real) : Real
	{}

	/**
	  * The minimum of self and r.
	  * post: if self <= r then result = self else result = r endif
	  */
	min(r : Real) : Real
	{}

	/**
	  * True if self is less than r.
	  */
	infix "<" (r : Real) : Boolean
	{}

	/**
	  * True if self is greater than r.
	  * post: result = not (self <= r)
	  */
	infix ">" (r : Real) : Boolean
	{}
	
	/**
	  * True if self is less than or equal to r.
	  * post: result = ((self = r) or (self < r))
	  */	  
	infix "<=" (r : Real) : Boolean
	{}

	/**
	  * True if self is greater than or equal to r.
	  * post: result = ((self = r) or (self > r))
	  */
	infix ">=" (r : Real) : Boolean
	{}
}	

class integer extends real
{
	/**
	  * The negative value of self.
	  */
	infix "-" : Integer
	{}

	infix "+" (i : Integer) : Integer
	{
		// The value of the addition of self and i.
	}

	infix "-" (i : Integer) : Integer
	{
		// The value of the subtraction of i from self.
	}
	
	infix "*" (i : Integer) : Integer
	{ 
		// The value of the multiplication of self and i.
	}

	infix "/" (i : Integer) : Real
	{
		// The value of self divided by i.
	}
	
	abs() : Integer
	{ //The absolute value of self. 
	  // post: if self < 0 then result = - self else result = self endif
	}

	div( i : Integer) : Integer
	{
		// The number of times that i fits completely within self.
		// pre : i <> 0
		// post: if self / i >= 0 then result = (self / i).floor()
		//       else result = -((-self/i).floor())
		//		 endif
	}

	mod( i : Integer) : Integer
	{
		// The result is self modulo i.
		// post: result = self - (self.div(i) * i)
	}
	
	max(i : Integer) : Integer
	{
		// The maximum of self an i.
		// post: if self >= i then result = self else result = i endif
	}
	
	min(i : Integer) : Integer
	{
		// The minimum of self an i.
		// post: if self <= i then result = self else result = i endif
	}
}
	
class String extends OclAny
{
	size() : Integer
	{ 
		// The number of characters in self.
	}
	
	concat(s : String) : String
	{ 
		// The concatenation of self and s.
		// post: result.size() = self.size() + string.size()
		// post: result.substring(1, self.size() ) = self
		// post: result.substring(self.size() + 1, result.size() ) = s
	}
	
	substring(lower : Integer, upper : Integer) : String
	{
		// The sub-string of self starting at character number lower, up to and including character number upper.
		// Character numbers run from 1 to self.size().
		// pre: 1 <= lower
 		// pre: lower <= upper
		// pre: upper <= self.size()
	}
	
	toInteger() : Integer
	{ 
		// Converts self to an Integer value.
	}
	
	toReal() : Real
	{ 	// Converts self to a Real value. }
}

class Boolean extends OclAny
{
	infix "or" (b : Boolean) : Boolean
	{
		// True if either self or b is true.
	}
	
	infix "xor" (b : Boolean) : Boolean
	{
		// True if either self or b is true, but not both.
		// post: (self or b) and not (self = b)
	}
	
	infix "and" (b : Boolean) : Boolean
	{
		// True if both b1 and b are true.
	}
	
	prefix "not" : Boolean
	{ 
		// True if self is false.
		// post: if self then result = false else result = true endif
	}
	
	infix "implies" (b : Boolean) : Boolean
	{
		// True if self is false, or if self is true and b is true.
		// post: (not self) or (self and b)
	}
}

// ******************************
// * Collection related classes *
// ******************************
/** 
  * Iterator for collection
  * this is a non typed iterator, this is needed because we don't know weither it is a 
  * we may in the future implement a typedIterator (when the classes will support templates)
  */
class iterator extends OclAny
	start()
	{
      // Positions the iterator to the first object in the
      // aggregate to be traversed.
    }

   	is_off(): Boolean
   	{
      // Returns true when there are no more objects in the
      // sequence.
   	}

   	item(): OclAny
   	{
      // Returns the object at the current position in the sequence.
      // pre  not is_off
	}
   	
   	next()
   	{
      	// Positions the iterator to the next object in the sequence.
		// pre:  not is_off
	}
}

/**
  * TODO : correct the pre and post which are currently the same as the OCL, they must be adapted to Bmtl
  */
class Collection extends OclAny
{
	get_new_iterator() : iterator
	{
		// create a new iterator for this collection
	}
	
	size() : Integer
	{
		// The number of elements in the collection self.
		// post: result = self->iterate(elem; acc : Integer = 0 | acc + 1)
	}
	
	includes(object : OclAny) : Boolean
	{
		// True if object is an element of self, false otherwise.
		// post: result = (self->count(object) > 0)
	}
	
	excludes(object : OclAny) : Boolean
	{
		// True if object is not an element of self, false otherwise.
		// post: result = (self->count(object) = 0)
	}
		
	count(object : OclAny) : Integer
	{
		// The number of times that object occurs in the collection self.
		// post: result = self->iterate( elem; acc : Integer = 0 |
		//					if elem = object then acc + 1 else acc endif)
	}
	
	includesAll(c2 : Collection) : Boolean
	{
		// Does self contain all the elements of c2 ?
		// post: result = c2->forAll(elem | self->includes(elem))
	}
	
	excludesAll(c2 : Collection) : Boolean
	{
		// Does self contain none of the elements of c2 ?
		// post: result = c2->forAll(elem | self->excludes(elem))
	}
	
	isEmpty() : Boolean
	{
		// Is self the empty collection?
		// post: result = ( self->size() = 0 )
	}
	
	notEmpty() : Boolean
	{
		// Is self not the empty collection?
		// post: result = ( self->size() <> 0 )
	}
	
	sum() : OclAny
	{
		// The addition of all elements in self. Elements must be of a type supporting the + operation. The + operation
		// must take one parameter of type T and be both associative: (a+b)+c = a+(b+c), and commutative:
		// a+b = b+a. Integer and Real fulfill this condition.
		// post: result = self->iterate( elem; acc : T = 0 | acc + elem )
	}

	product(c2: Collection) : Set( Tuple( first: OclAny, second: OclAny) )
	{
		// The cartesian product operation of self and c2.
		// post: result = self->iterate (e1; acc: Set(Tuple(first: T, second: T2)) = Set{} |	
		//							c2->iterate (e2; acc2: Set(Tuple(first: T, second: T2)) = acc |
		//							acc2->including (Tuple{first = e1, second = e2}) ) )
	}
}

class Set extends Collection
{
	union(s : Set) : Set
	{
		// The union of self and s.
		// post: result->forAll(elem | self->includes(elem) or s->includes(elem))
		// post: self ->forAll(elem | result->includes(elem))
		// post: s ->forAll(elem | result->includes(elem))
	}
	
	union(bag : Bag) : Bag
	{ 
		// The union of self and bag.
		// post: result->forAll(elem | result->count(elem) = self->count(elem) + bag->count(elem))
		// post: self->forAll(elem | result->includes(elem))
		// post: bag ->forAll(elem | result->includes(elem))
	}
	
	infix "=" (s : Set) : Boolean
	{
		// Evaluates to true if self and s contain the same elements.
		// post: result = (self->forAll(elem | s->includes(elem)) and
		// 					s->forAll(elem | self->includes(elem)) )
	}

	intersection(s : Set) : Set
	{
		// The intersection of self and s (i.e, the set of all elements that are in both self and s).
		// post: result->forAll(elem | self->includes(elem) and s->includes(elem))
		// post: self->forAll(elem | s ->includes(elem) = result->includes(elem))
		// post: s ->forAll(elem | self->includes(elem) = result->includes(elem))
	}
	
	intersection(bag : Bag) : Set
	{
		// The intersection of self and bag.
		// post: result = self->intersection( bag->asSet )
	}
	
	infix "-" (s : Set) : Set
	{
		// The elements of self, which are not in s.
		// post: result->forAll(elem | self->includes(elem) and s->excludes(elem))
		// post: self ->forAll(elem | result->includes(elem) = s->excludes(elem))
	}
	
	including(object : OclAny) : Set
	{
		// The set containing all elements of self plus object.
		// post: result->forAll(elem | self->includes(elem) or (elem = object))
		// post: self- >forAll(elem | result->includes(elem))
		// post: result->includes(object)
	}

	excluding(object : OclAny) : Set
	{
		// The set containing all elements of self without object.
		// post: result->forAll(elem | self->includes(elem) and (elem <> object))
		// post: self- >forAll(elem | result->includes(elem) = (object <> elem))
		// post: result->excludes(object)
	}
	symmetricDifference(s : Set) : Set
	{
		// The sets containing all the elements that are in self or s, but not in both.
		// post: result->forAll(elem | self->includes(elem) xor s->includes(elem))
		// post: self->forAll(elem | result->includes(elem) = s ->excludes(elem))
		// post: s ->forAll(elem | result->includes(elem) = self->excludes(elem))
	}

	count(object : OclAny) : Integer
	{
		// The number of occurrences of object in self.
		// post: result <= 1
	}
	
	flatten() : Set
	{
		// If the element type is not a collection type this result in the same self. If the element type is a collection
		// type, the result is the set containing all the elements of all the elements of self.
		// post: result = if self.type.elementType.oclIsKindOf(CollectionType) then
		// 						self->iterate(c; acc : Set() = Set{} |
		// 						acc->union(c->asSet() ) )
		// 				   else
		// 						self
		// 				   endif
	}
	
	asSet() : Set
	{
		// A Set identical to self. This operation exists for convenience reasons.
		// post: result = self
	}
	
	asOrderedSet() : OrderedSet
	{
		// An OrderedSet that contains all the elements from self, in undefined order.
		// post: result->forAll(elem | self->includes(elem))
	}
	
	asSequence() : Sequence
	{
		// A Sequence that contains all the elements from self, in undefined order.
		// post: result->forAll(elem | self->includes(elem))
		// post: self->forAll(elem | result->count(elem) = 1)
	}
	
	asBag() : Bag
	{
		// The Bag that contains all the elements from self.
		// post: result->forAll(elem | self->includes(elem))
		// post: self->forAll(elem | result->count(elem) = 1)
	}
}

class OrderedSet extends collection
{
	append (object: OclAny) : OrderedSet
	{
		// The set of elements, consisting of all elements of self, followed by object.
		// post: result->size() = self->size() + 1
		// post: result->at(result->size() ) = object
		// post: Sequence{1..self->size() }->forAll(index : Integer |
		// 											result->at(index) = self ->at(index))
	}
	
	prepend(object : OclAny) : OrderedSet
	{
		// The sequence consisting of object, followed by all elements in self.
		// post: result->size = self->size() + 1
		// post: result->at(1) = object
		// post: Sequence{1..self->size()}->forAll(index : Integer |
		// 											self->at(index) = result->at(index + 1))
	}
	
	insertAt(index : Integer, object : OclAny) : OrderedSet
	{
		// The set consisting of self with object inserted at position index.
		// post: result->size = self->size() + 1
		// post: result->at(index) = object
		// post: Sequence{1..(index - 1)}->forAll(i : Integer |
		// 										self->at(i) = result->at(i))
		// post: Sequence{(index + 1)..self->size()}->forAll(i : Integer |
		// 										self->at(i) = result->at(i + 1))
	}
	

	subOrderedSet(lower : Integer, upper : Integer) : OrderedSet
	{
		// The sub-set of self starting at number lower, up to and including element number upper.
		// pre : 1 <= lower
		// pre : lower <= upper
		// pre : upper <= self->size()
		// post: result->size() = upper -lower + 1
		// post: Sequence{lower..upper}->forAll( index |
		// 										result->at(index - lower + 1) =
		// 			self->at(index))
	}
	
	at(i : Integer) : OclAny
	{
		// The i-th element of self.
		// pre : i >= 1 and i <= self->size()
	}
	
	indexOf(obj : OclAny) : Integer
	{
		// The index of object obj in the sequence.
		// pre : self->includes(obj)
		// post : self->at(i) = obj
	}
	
	first() : OclAny
	{
		// The first element in self.
		// post: result = self->at(1)
	}
	
	last() : OclAny
	{	
		// The last element in self.
		// post: result = self->at(self->size() )
	}
	
class Bag extends Collection
{
	infix "=" (bag : Bag) : Boolean
	{
		// True if self and bag contain the same elements, the same number of times.
		// post: result = (self->forAll(elem | self->count(elem) = bag->count(elem)) and
		// 					bag->forAll(elem | bag->count(elem) = self->count(elem)) )
	}
	
	union(bag : Bag) : Bag
	{
		// The union of self and bag.
		// post: result->forAll( elem | result->count(elem) = self->count(elem) + bag->count(elem))
		// post: self ->forAll( elem | result->count(elem) = self->count(elem) + bag->count(elem))
		// post: bag ->forAll( elem | result->count(elem) = self->count(elem) + bag->count(elem))
	}

	union(set : Set) : Bag
	{
		// The union of self and set.
		// post: result->forAll(elem | result->count(elem) = self->count(elem) + set->count(elem))
		// post: self ->forAll(elem | result->count(elem) = self->count(elem) + set->count(elem))
		// post: set ->forAll(elem | result->count(elem) = self->count(elem) + set->count(elem))
	}
	
	intersection(bag : Bag) : Bag
	{
		// The intersection of self and bag.
		// post: result->forAll(elem |
		// 					result->count(elem) = self->count(elem).min(bag->count(elem)) )
		// post: self->forAll(elem |
		// 					result->count(elem) = self->count(elem).min(bag->count(elem)) )
		// post: bag->forAll(elem |
		// 					result->count(elem) = self->count(elem).min(bag->count(elem)) )
	}
	
	intersection(set : Set) : Set
	{
		// The intersection of self and set.
		// post: result->forAll(elem|result->count(elem) = self->count(elem).min(set->count(elem)) )
		// post: self ->forAll(elem|result->count(elem) = self->count(elem).min(set->count(elem)) )
		// post: set ->forAll(elem|result->count(elem) = self->count(elem).min(set->count(elem)) )
	}
	
	including(object : OclAny) : Bag
	{
		// The bag containing all elements of self plus object.
		// post: result->forAll(elem |
		// 					if elem = object then
		// 						result->count(elem) = self->count(elem) + 1
		// 					else
		// 						result->count(elem) = self->count(elem)
		// 					endif)
		// post: self->forAll(elem |
		// 					if elem = object then
		// 						result->count(elem) = self->count(elem) + 1
		// 					else
		// 						result->count(elem) = self->count(elem)
		// 					endif)
	}
	
	excluding(object : OclAny) : Bag
	{
		// The bag containing all elements of self apart from all occurrences of object.
		// post: result->forAll(elem |
		// 					if elem = object then
		// 						result->count(elem) = 0
		// 					else
		// 						result->count(elem) = self->count(elem)
		// 					endif)
		// post: self->forAll(elem |
		// 					if elem = object then
		// 						result->count(elem) = 0
		// 					else
		// 						result->count(elem) = self->count(elem)
		// 					endif)
	}
	
	count(object : OclAny) : Integer
	{
		// The number of occurrences of object in self.
	}
	
	flatten() : Bag
	{
		// If the element type is not a collection type this result in the same bag. If the element type is a collection
		// type, the result is the bag containing all the elements of all the elements of self.
		// post: result = if self.type.elementType.oclIsKindOf(CollectionType) then
		// 					self->iterate(c; acc : Bag() = Bag{} |
		// 						acc->union(c->asBag() ) )
		// 				   else
		// 						self
		// 				   endif
	}
	
	asBag() : Bag
	{
		// A Bag identical to self. This operation exists for convenience reasons.
		// post: result = self
	}
	
	asSequence() : Sequence
	{
		// A Sequence that contains all the elements from self, in undefined order.
		// post: result->forAll(elem | self->count(elem) = result->count(elem))
		// post: self ->forAll(elem | self->count(elem) = result->count(elem))
	}
	
	asSet() : Set
	{
		// The Set containing all the elements from self, with duplicates removed.
		// post: result->forAll(elem | self ->includes(elem))
		// post: self ->forAll(elem | result->includes(elem))
	}
	
	asOrderedSet() : OrderedSet
	{
		// An OrderedSet that contains all the elements from self, in undefined order, with duplicates removed.
		// post: result->forAll(elem | self ->includes(elem))
		// post: self ->forAll(elem | result->includes(elem))
		// post: self ->forAll(elem | result->count(elem) = 1)
	}

class Sequence extends Collection
{
	count(object : OclAny) : Integer
	{
		// The number of occurrences of object in self.
	}
	
	infix "=" (s : Sequence) : Boolean
	{
		// True if self contains the same elements as s in the same order.
		// post: result = Sequence{1..self->size()}->forAll(index : Integer |
		// 							self->at(index) = s->at(index))
		// 						and
		// 							self->size() = s->size()
	}
	
	union (s : Sequence) : Sequence
	{
		// The sequence consisting of all elements in self, followed by all elements in s.
		// post: result->size() = self->size() + s->size()
		// post: Sequence{1..self->size()}->forAll(index : Integer |
		// 						self->at(index) = result->at(index))
		// post: Sequence{1..s->size()}->forAll(index : Integer |
		// 						s->at(index) = result->at(index + self->size() )))
	}
	
	flatten() : Sequence
	{
		// If the element type is not a collection type this result in the same self. If the element type is a collection
		// type, the result is the seuqnce containing all the elements of all the elements of self. The order of the
		// elements is partial.
		// post: result = if self.type.elementType.oclIsKindOf(CollectionType) then
		// 					self->iterate(c; acc : Sequence() = Sequence{} |
		// 					acc->union(c->asSequence() ) )
		// 				  else
		// 					self
		// 				  endif
	}
	
	append (object: OclAny) : Sequence
	{
		// The sequence of elements, consisting of all elements of self, followed by object.
		// post: result->size() = self->size() + 1
		// post: result->at(result->size() ) = object
		// post: Sequence{1..self->size() }->forAll(index : Integer |
		// 			result->at(index) = self ->at(index))
	}
	
	prepend(object : OclAny) : Sequence
	{
		// The sequence consisting of object, followed by all elements in self.
		// post: result->size = self->size() + 1
		// post: result->at(1) = object
		// post: Sequence{1..self->size()}->forAll(index : Integer |
		// 				self->at(index) = result->at(index + 1))
	}
	
	insertAt(index : Integer, object : OclAny) : Sequence
	{
		// The sequence consisting of self with object inserted at position index.
		// post: result->size = self->size() + 1
		// post: result->at(index) = object
		// post: Sequence{1..(index - 1)}->forAll(i : Integer |
		// 			self->at(i) = result->at(i))
		// post: Sequence{(index + 1)..self->size()}->forAll(i : Integer |
		// 			self->at(i) = result->at(i + 1))
	}
	
	subSequence(lower : Integer, upper : Integer) : Sequence
	{
		// The sub-sequence of self starting at number lower, up to and including element number upper.
		// pre : 1 <= lower
		// pre : lower <= upper
		// pre : upper <= self->size()
		// post: result->size() = upper -lower + 1
		// post: Sequence{lower..upper}->forAll( index |
		// 					result->at(index - lower + 1) =
		// 						self->at(index))
	}
	
	at(i : Integer) : OclAny
	{
		// The i-th element of sequence.
		// pre : i >= 1 and i <= self->size()
	}
	
	indexOf(obj : OclAny) : Integer
	{
		// The index of object obj in the sequence.
		// pre : self->includes(obj)
		// post : self->at(i) = obj
	}
	
	first() : OclAny
	{
		// The first element in self.
		// post: result = self->at(1)
	}
	
	last() : OclAny
	{
		// The last element in self.
		// post: result = self->at(self->size() )
	}
	
	including(object : OclAny) : Sequence
	{
		// The sequence containing all elements of self plus object added as the last element.
		// post: result = self.append(object)
	}

	excluding(object : OclAny) : Sequence
	{
		// The sequence containing all elements of self apart from all occurrences of object.
		// The order of the remaining elements is not changed.
		// post:result->includes(object) = false
		// post: result->size() = self->size() - self->count(object)
		// post: result = self->iterate(elem; acc : Sequence(T)
		// 				= Sequence{}|
		// 				if elem = object then acc else acc->append(elem) endif )
	}
	
	asBag() : Bag
	{
		// The Bag containing all the elements from self, including duplicates.
		// post: result->forAll(elem | self->count(elem) = result->count(elem) )
		// post: self->forAll(elem | self->count(elem) = result->count(elem) )
	}
	
	asSequence() : Sequence
	{
		// The Sequence identical to the object itself. This operation exists for convenience reasons.
		// post: result = self
	}
	
	asSet() : Set
	{
		// The Set containing all the elements from self, with duplicated removed.
		// post: result->forAll(elem | self ->includes(elem))
		// post: self ->forAll(elem | result->includes(elem))
	}
	
	asOrderedSet() : OrderedSet
	{
		// An OrderedSet that contains all the elements from self, in the same order, with duplicates removed.
		// post: result->forAll(elem | self ->includes(elem))
		// post: self ->forAll(elem | result->includes(elem))
		// post: self ->forAll(elem | result->count(elem) = 1)
		// post: self ->forAll(elem1, elem2 |
		// 						self->indexOf(elem1) < self->indexOf(elem2)
		// 						implies result->indexOf(elem1) < result->indexOf(elem2) )
	}
}