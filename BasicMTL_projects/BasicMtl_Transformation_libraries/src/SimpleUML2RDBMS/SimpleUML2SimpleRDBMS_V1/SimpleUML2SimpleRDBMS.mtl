/**
 * $Id: SimpleUML2SimpleRDBMS.mtl,v 1.3 2003-07-31 09:13:11 dvojtise Exp $
 *
 *	Standalone transformation that do the mapping between a SimpleUML metamodel and a SimpleRDBMS metamodel
 * this version is the first and simpliest one, it neither try to be generalizable, nor to be well structured
 * (see further versions of this transformation for that)
 * this first variant use only the library operations structure (not the classes), this means that the 
 * operations should be better structured in another version.
 *
 * version written for BasicMtl 1.1
 *	(cf /udd/triskell/cvsroot/dev/MT/BasicMtlAntlr/src/ANTLRParser/basicmtl.g,v 1.1)
 * 
 * $Revision: 1.3 $ $Date: 2003-07-31 09:13:11 $
 * Last modification by : $Author: dvojtise $
 * Authors : dvojtise, jpthibau
 *
 */
 
library SimpleUML2SimpleRDBMS ;
// no extends for this lib
 
// Use of other libs : this not needed anymore : for information only
// use lang.Standard
// use RepositoryDriver.MDRdriver		// this is a native lib that provides an access  to a driver
									// this driver allows to instantiate, load models, either with
									// methods with a lot of parameter, or opening a GUI
									
// import shortcuts (like java import) are not currently supported

// Lib local model 
model source_model : RepositoryModel;		// should be SimpleUML MetaModel
model target_model : RepositoryModel;		// must be SimpleRDBMS MetaModel

model source_model2 is MyLib;

// they are not typed so this implies that any access to them will be done through "invoke"
// no typed model 
// 		syntax for typed model :
//			Model mymodel is LibraryName

// Library level methods
// ---------------------
// Note : should be put into a class which name is the same as the library ? NO

// Library contructors
// -------------------
// main of the lib (also its constructor)

creation make( a_source_model:RepositoryModel; a_target_model:RepositoryModel; a_source2 : MyLib)
{

	source_model = a_source_model;
	target_model = a_target_model;
	source_model2 = a_source2;
}


// other library level methods
// ---------------------------

UMLToRDBMS() : Standard::void
{	
	// Start the different phasis of the transformation
	UMLClassesToRDBMS();
	UMLAssociationsToRDBMS();
}


UMLClassesToRDBMS() : Standard::void
{
	// look for all the sources classes 
		// this will be improved when the ocl select will be available
	classIterator : Standard::Iterator;
	classSet : Standard::Set;	
	// Note : is  this the correct syntax for calling allInstance on a model ?
	
	// monOclType : OclType;
	// monOclType = source_model::Class;
	
	classSet = source_model::Class.allInstances();
	classSet = monOclType.allInstances();
	truc.isTypeOf(source_model::Class);
	truc.isTypeOf(monOclType);
	// classSet = source_model.allInstances('Class');
	


	classIterator = classSet.get_new_iterator();
	classIterator.start();
	while classIterator.is_off().not() 
	{		
		UMLClassToRDBMS(classIterator.item());  // return value not used
		
		classIterator.next();
	}
	
	
	// for each attribute of type class
	classIterator = classSet.get_new_iterator();
	classIterator.start();
	while classIterator.is_off().not()
	{
		
		UMLClassToRDBMS(classIterator.item());  // return value not used
				
		classIterator.next();
	}
}

UMLClassToRDBMS(sourceClass : source_model::Class) : target_model::Table
{
}

UMLClassToRDBMS(sourceClass : source_model::Class  ) : target_model::Table
{
	// local variable at the beginning of the method
	// (todo allow variable declaration anywhere ...
	aTable : target_model::Table;
	attributeIterator : Standard::Iterator;
	attributeSet : Standard::Set;
	aColumn : target_model::Column;
	primitiveAttribute : source_model::Classifier;
	aString : Standard::String;
	
	
	// create a table for this class  (use the default constructor)
	aTable = new target_model::Table();
	// there must probably exists a better syntax for modelElement creation
	aTable.name = sourceClass.name;
	aTable.kind = sourceClass.kind;

	// for each attribute of primitive data type create a column for this type	
	attributeSet = classIterator.item().attribute();
	attributeIterator.start();
	while attributeIterator.is_off().not()
	{
		if 	attributeIterator.item().type().oclIsKindOf('source_model::PrimitiveDataType')
		{
			// create a new column to the table
			primitiveAttribute = attributeIterator.item();
			aColumn = new target_model::Column();
			aColumn.name = primitiveAttribute.name;
			aColumn.kind = primitiveAttribute.kind;
			aString = primitiveAttribute.type.name;
			if  aString.equals('int')
			{	
				aColumn.type = 'NUMBER';
			}
			else
			{
				aColumn.type = 'VARCHAR';
			}
			// associate : complete syntax	
			associate (column = aColumn : Column, owner = aTable : Table);
			aString = primitiveAttribute.kind;
			if  aString.equals('primary')
			{
				// if the attribute kind is primary, the cloumn is bound the the key
				// associate : complete syntax	
				associate (column = aColumn : Column, belongsTo = aKey : Key);
				// other syntax : (because the is enough information)
				// associate aColumn, aKey
				// associate aColumn : Column, aKey : Key
				// associate column = aColumn, belongsTo = aKey
			}
			
		}
		attributeIterator.next();
	}
	return( aTable);
}




// classes for this library
// ------------------------
// None
